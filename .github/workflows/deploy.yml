name: Backend CI/CD

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: baequest-server/package-lock.json

      - run: npm ci
        working-directory: baequest-server

      # gaxios (google-auth-library dep) has a minimatch ReDoS in its internal rimraf/glob chain.
      # No non-breaking fix is available upstream; the patterns are hardcoded, so actual risk is zero.
      # Auditing at critical level catches CVSS>=9 while skipping this unfixable high.
      - run: npm audit --audit-level=critical --omit=dev
        working-directory: baequest-server

      - run: npm run lint
        working-directory: baequest-server

      - run: npm test
        working-directory: baequest-server

  build-and-deploy:
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./baequest-server
          tags: baequest-backend:latest
          load: true

      - name: Save image to tarball
        run: docker save baequest-backend:latest -o image.tar

      - name: Upload image as release asset
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          TAG="deploy-${{ github.sha }}"

          # Delete existing release/tag if it exists (from previous failed run)
          EXISTING_RELEASE=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/tags/$TAG" \
            -H "Authorization: token $GITHUB_TOKEN")
          EXISTING_ID=$(echo "$EXISTING_RELEASE" | node -pe "try{JSON.parse(require('fs').readFileSync(0,'utf8')).id||''}catch(e){''}")
          if [ -n "$EXISTING_ID" ]; then
            echo "Deleting existing release: $EXISTING_ID"
            curl -sX DELETE "https://api.github.com/repos/${{ github.repository }}/releases/$EXISTING_ID" \
              -H "Authorization: token $GITHUB_TOKEN"
            curl -sX DELETE "https://api.github.com/repos/${{ github.repository }}/git/refs/tags/$TAG" \
              -H "Authorization: token $GITHUB_TOKEN"
          fi

          RELEASE=$(curl -sX POST \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{\"tag_name\":\"$TAG\",\"name\":\"deploy\"}")
          echo "Release response: $RELEASE"
          RELEASE_ID=$(echo "$RELEASE" | node -e "const d=require('fs').readFileSync(0,'utf8');const id=JSON.parse(d).id;if(!id){console.error('Failed to create release');process.exit(1)}console.log(id)")
          echo "Release ID: $RELEASE_ID"
          UPLOAD_STATUS=$(curl -s -o /dev/null -w '%{http_code}' -X POST \
            "https://uploads.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID/assets?name=image.tar" \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Content-Type: application/octet-stream" \
            --data-binary @image.tar)
          echo "Upload HTTP status: $UPLOAD_STATUS"
          [ "$UPLOAD_STATUS" = "201" ] || { echo "ERROR: Asset upload failed with status $UPLOAD_STATUS"; exit 1; }
          echo "RELEASE_ID=$RELEASE_ID" >> $GITHUB_ENV
          echo "RELEASE_TAG=$TAG" >> $GITHUB_ENV

      - name: Deploy via SSH pull
        env:
          BACKEND_ENV: ${{ secrets.BACKEND_ENV_FILE }}
        run: |
          echo "${{ secrets.GC_SSH_KEY }}" > /tmp/deploy_key
          chmod 600 /tmp/deploy_key
          HOST="${{ secrets.GC_SERVER_USER }}@${{ secrets.GC_SERVER_HOST }}"
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/$RELEASE_TAG/image.tar"

          # Create .env file on VM
          echo "$BACKEND_ENV" | ssh -i /tmp/deploy_key -o StrictHostKeyChecking=no -o BatchMode=yes \
            -o ConnectTimeout=10 "$HOST" "cat > /home/badiakaseydou/.env"

          # Write deploy script to a file.
          # Runner expands ${DOWNLOAD_URL}; \$ passes $ through to the remote shell.
          cat > /tmp/deploy.sh << DEPLOY_SCRIPT
          #!/bin/bash
          set -eo pipefail

          DOWNLOAD_URL="${DOWNLOAD_URL}"
          ACTIVE_PORT_FILE="/home/badiakaseydou/.active-port"

          # Determine blue-green ports and container names
          if [ -f "\$ACTIVE_PORT_FILE" ]; then
            OLD_PORT=\$(cat "\$ACTIVE_PORT_FILE")
          else
            OLD_PORT=3001
          fi

          if [ "\$OLD_PORT" = "3001" ]; then
            NEW_PORT=3002
            OLD_NAME="baequest-backend-a"
            NEW_NAME="baequest-backend-b"
          else
            NEW_PORT=3001
            OLD_NAME="baequest-backend-b"
            NEW_NAME="baequest-backend-a"
          fi

          echo "Blue-green: \$OLD_NAME (port \$OLD_PORT) → \$NEW_NAME (port \$NEW_PORT)"

          # Normalize legacy container name on first deploy with this scheme
          docker rename baequest-backend "\$OLD_NAME" 2>/dev/null || true

          # Tag current image as rollback point
          docker tag baequest-backend:latest baequest-backend:previous 2>/dev/null || true

          # Clean up dangling images and stopped containers (old container still serving)
          journalctl --vacuum-size=50M 2>/dev/null || true
          docker container prune -f 2>/dev/null || true
          docker image prune -f 2>/dev/null || true

          # Load new image while old container still serves traffic
          curl -sL "\$DOWNLOAD_URL" | docker load || { echo "LOAD_FAILED"; df -h /; exit 1; }

          # Free the new port in case something grabbed it
          fuser -k "\${NEW_PORT}/tcp" 2>/dev/null || true

          # Start new container on alternate port (old container still up and serving)
          docker run -d --name "\$NEW_NAME" \
            -p "\${NEW_PORT}:3001" \
            --restart=unless-stopped \
            --env-file /home/badiakaseydou/.env \
            baequest-backend:latest || { echo "New container failed to start"; exit 1; }

          # Health check new container before touching nginx
          echo "Health checking new container on port \$NEW_PORT..."
          HEALTHY=0
          for i in 1 2 3 4 5 6 7 8 9 10; do
            sleep 6
            if curl -sf "http://localhost:\${NEW_PORT}/health" > /dev/null 2>&1; then
              HEALTHY=1
              echo "Health check passed on attempt \$i"
              break
            fi
            echo "Health check attempt \$i/10 failed"
          done

          if [ "\$HEALTHY" -ne 1 ]; then
            echo "Health checks failed — old container still serving on port \$OLD_PORT"
            echo "=== Container logs ==="
            docker logs "\$NEW_NAME" --tail 40 2>&1 || true
            echo "=== Container status ==="
            docker inspect "\$NEW_NAME" --format='{{.State.Status}} (exit {{.State.ExitCode}})' 2>&1 || true
            docker stop "\$NEW_NAME" 2>/dev/null || true
            docker rm "\$NEW_NAME" 2>/dev/null || true
            exit 1
          fi

          # Switch nginx to new container (graceful reload, no dropped connections)
          sudo sed -i "s|proxy_pass http://localhost:300[12];|proxy_pass http://localhost:\${NEW_PORT};|" \
            /etc/nginx/sites-enabled/baequests.com
          sudo nginx -s reload
          echo "Nginx switched to port \$NEW_PORT"

          # Stop old container (traffic already routed away)
          docker stop "\$OLD_NAME" 2>/dev/null || true
          docker rm "\$OLD_NAME" 2>/dev/null || true

          # Record new active port for next deploy
          echo "\$NEW_PORT" > "\$ACTIVE_PORT_FILE"

          # Clean up previous image to free disk
          docker rmi baequest-backend:previous 2>/dev/null || true
          echo "RUN_EXIT=0"
          docker ps
          DEPLOY_SCRIPT

          ssh -i /tmp/deploy_key -o StrictHostKeyChecking=no -o BatchMode=yes \
            -o ConnectTimeout=10 "$HOST" bash -s < /tmp/deploy.sh 2>&1 | tee /tmp/deploy_debug.log

          rm -f /tmp/deploy_key /tmp/deploy.sh

          if grep -q "RUN_EXIT=0" /tmp/deploy_debug.log; then
            echo "Deploy succeeded"
          else
            echo "Deploy failed - check artifact for details"
            exit 1
          fi

      - name: Upload deploy debug log
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-debug-log
          path: /tmp/deploy_debug.log

      - name: Cleanup release
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -n "${RELEASE_ID:-}" ]; then
            curl -sX DELETE \
              "https://api.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID" \
              -H "Authorization: token $GITHUB_TOKEN"
            curl -sX DELETE \
              "https://api.github.com/repos/${{ github.repository }}/git/refs/tags/$RELEASE_TAG" \
              -H "Authorization: token $GITHUB_TOKEN"
          fi
